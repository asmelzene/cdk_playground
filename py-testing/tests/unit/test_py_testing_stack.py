import aws_cdk as core
import aws_cdk.assertions as assertions
import pytest
from aws_cdk.assertions import Match, Capture

# https://github.com/alexhddev/cdkpro/tree/main
# because of the below path, we need to run py-testing in "py_testing" root folder
from py_testing.py_testing_stack import PySimpleStack

# we don't want below 3 lines in order to receive a template code each time.
# we don't want to write them for each test scenario and ending up duplicated code
# also, this is a long operation. we want our tests faster by only sybthesizing the template 
# once in the beginning of our test suite and then using that template tthroughout our test.
# we can do this optimization by using python fixtures
# and we will create an initializer method with the annotation pytest.fixture(scope="session")
# if I wouldn't give this argument (scope="session") then this method would be called for 
# every test. but since the same template is used, we can only run once.
@pytest.fixture(scope="session")
def simple_template():
    # a stack needs an application object in order to exist
    app = core.App()
    # then create a stack
    stack = PySimpleStack(app, "py-testing")
    # then we are using a special method from the CDK testing library called "Template.from_stack()"
    # basically, we are getting the JSON template for our stack object. this is something like
    # a synthesizing step specifically for testing
    template = assertions.Template.from_stack(stack)

    return template

# example tests. To run these tests, uncomment this file along with the example
# resource in py_testing/py_testing_stack.py
def test_lambda_props(simple_template): 
    # now we can query resources and properties
    # run 'cdk synth' and in the output, check the lambda to know what the type is exactly 
    # e.g. AWS::Lambda::Function and any properties related to it
    simple_template.has_resource_properties("AWS::Lambda::Function", {
        "Runtime": "python3.11"
    })

    # check # of resources in our template
    simple_template.resource_count_is("AWS::Lambda::Function", 1)

# python matchers
def test_lambda_runtime_with_matcher(simple_template): 
    # now we can query resources and properties
    # run 'cdk synth' and in the output, check the lambda to know what the type is exactly 
    # e.g. AWS::Lambda::Function and any properties related to it
    simple_template.has_resource_properties("AWS::Lambda::Function", {
        "Runtime": Match.string_like_regexp("python")
    })

    # check # of resources in our template
    simple_template.resource_count_is("AWS::Lambda::Function", 1)

# let's say we want to check the interaction between our function and our bucket
# we already grant the permission to our loambda function to access the bucket
# and that access translates into an IAM policy object 
# (see cdk_playground/py-testing/cdk.out/PySimpleStack.template.json >> SimpleLambdaServiceRoleDefaultPolicy)
# we can use matchers to go into this IAM policy objects and check different values of different keywords
# but the problem is, for example, here our template is generated with an AWS IAM policy entry.
# but it's a resource that it affects somehow it resembles the name of our bucket or the ID of our bucket
# SimpleBucket250AC437 which is (SimpleBucket)
# then we also have a randomly generated part that is generated by CDK (250AC437)
# we can't know this value beforehand, so, how can we test this interaction? 
# so, we can consider more complex matchers here. e.g. Match.object_like()
def test_lambda_bucket_with_matchers(simple_template):
    simple_template.has_resource_properties(
        "AWS::IAM::Policy",
        Match.object_like(
            {
                "PolicyDocument": {
                    "Statement": [
                        {
                            "Resource": [
                                {
                                    "Fn::GetAtt": [
                                        Match.string_like_regexp("SimpleBucket"),
                                        "Arn",
                                    ]
                                },
                                Match.any_value(),
                            ]
                        }
                    ]
                }
            }
        ),
    )

# if we specify an action as an object type of the capture, then CDK will save the contents of our object
# inside this capture. then now, we can use this capture to make assertions for our code
def test_lambda_actions_with_captures(simple_template):
    lambda_actions_capture = Capture()
    simple_template.has_resource_properties(
        "AWS::IAM::Policy",
        {"PolicyDocument": {"Statement": [{"Action": lambda_actions_capture}]}},
    )

    expected_actions = [
        "s3:GetBucket*",
        "s3:GetObject*",
        "s3:List*"
       ]
    
    assert sorted(lambda_actions_capture.as_array()) == sorted(expected_actions)

# snapshot testing means taking a snapshot, usually in the form of json or something related,
# and taking an object and comparing it to the expected snapshot
# the problem with snapshot testing, especially for CDK, is that we are working with many automatically
# generated random values. so, this means they are not too friendly with snapshot testing
# first install syrupy (pip install syrupy)
# then we need to generate our snapshot with
# pytest --snapshot-update
# if we look at our unit test folder, we will see another folder created with the name "__snapshots__"
# basically, this is the representation of the object at the time the snapshot was generated
def test_bucket_props_with_snapshot(simple_template, snapshot):
    bucket_template = simple_template.find_resources("AWS::S3::Bucket")
    assert bucket_template ==snapshot